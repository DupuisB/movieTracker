/**
 * @OnlyCurrentDoc
 * Serve the HTML interface for the Movie Tracker web app.
 */
function doGet(e: GoogleAppsScript.Events.DoGet) {
  Logger.log("doGet function completed successfully. Preparing to return HTML.");
  // Serve the 'index.html' file which is generated by the build process
  return HtmlService.createHtmlOutputFromFile('index')
      .setTitle('Movie Tracker Deluxe')
      .addMetaTag('viewport', 'width=device-width, initial-scale=1')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.DEFAULT);
}

/**
 * Retrieves the TMDB API key securely from Script Properties.
 * @return {string} The TMDB API key.
 * @throws {Error} If the API key is not set in Script Properties.
 */
function getTmdbApiKey(): string {
  const apiKey = PropertiesService.getScriptProperties().getProperty('TMDB_API_KEY');
  if (!apiKey) {
    throw new Error("Clé API TMDB non configurée. Veuillez la définir dans 'Fichier > Propriétés du projet > Propriétés du script'.");
  }
  return apiKey;
}

/**
 * Retrieves the OMDb API key securely from Script Properties.
 */
function getOmdbApiKey(): string | null {
  const apiKey = PropertiesService.getScriptProperties().getProperty('OMDB_API_KEY');
  if (!apiKey) {
    Logger.log("Clé API OMDb non configurée."); 
  }
  return apiKey; 
}

/**
 * Fetches movie data from the Google Sheet.
 * @return {Array<Object>} An array of movie objects.
 */
function getMovies(): any[] {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Reading Log");
    if (!sheet) {
      throw new Error("La feuille 'Reading Log' est introuvable !");
    }
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    const headers = values[0]; // Get headers
    const movies = values.slice(1).map(row => {
      let obj: any = {};
      headers.forEach((header: string, index: number) => {
        // Attempt to extract URL and text from HYPERLINK formulas
        let cellValue = row[index];
        if (typeof cellValue === 'string' && cellValue.toUpperCase().startsWith('=HYPERLINK("')) {
          try {
             const match = cellValue.match(/=HYPERLINK\("([^"]+)"\s*,\s*"([^"]+)"\)/i);
             if (match && match.length === 3) {
                 obj[header + '_Url'] = match[1]; // Store URL separately
                 obj[header] = match[2]; // Store display text
             } else {
                 obj[header] = cellValue; // Fallback if parsing fails
             }
          } catch(e) {
             obj[header] = cellValue; // Fallback on error
          }
        } else if (cellValue instanceof Date) {
           obj[header] = cellValue.toLocaleDateString('en-US'); // Format date for display
        }
        else {
           obj[header] = cellValue;
        }
      });
      // Ensure essential fields have defaults if empty
      obj['TITRE FILM'] = obj['TITRE FILM'] || 'Titre inconnu';
      return obj;
    }).filter(movie => movie['TITRE FILM'] !== 'Titre inconnu'); // Filter out potentially empty rows

    // Sort by date descending (assuming DATE is the first column)
     movies.sort((a, b) => {
       const dateA = a.DATE ? new Date(a.DATE.split('/').reverse().join('-')) : new Date(0); // Handle potential non-date values
       const dateB = b.DATE ? new Date(b.DATE.split('/').reverse().join('-')) : new Date(0);
       // Check if dates are valid before comparing
       if (isNaN(dateA.getTime()) || isNaN(dateB.getTime())) {
         return 0; // Don't sort if dates are invalid
       }
       return dateB.getTime() - dateA.getTime(); // Descending order
     });

    return movies;
  } catch (error: any) {
    Logger.log("Error in getMovies: " + error);
    throw new Error("Impossible de récupérer les films depuis la feuille: " + error.message);
  }
}


/**
 * Searches for movies on TMDB.
 * @param {string} query The search term.
 * @return {Array<Object>} A list of movie results with basic info.
 */
function searchTmdb(query: string): any[] {
  if (!query || query.trim().length < 2) {
    return []; // Don't search for very short queries
  }
  try {
    const apiKey = getTmdbApiKey();
    const url = `https://api.themoviedb.org/3/search/movie?api_key=${apiKey}&query=${encodeURIComponent(query)}&language=en-US&include_adult=false`;
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const json = JSON.parse(response.getContentText());

    if (response.getResponseCode() !== 200 || !json.results) {
       Logger.log("TMDB Search Error: " + response.getContentText());
       throw new Error("Erreur de l'API TMDB lors de la recherche.");
    }

    return json.results.map((movie: any) => ({
      id: movie.id,
      title: movie.title,
      year: movie.release_date ? movie.release_date.substring(0, 4) : 'N/A',
      poster_path: movie.poster_path ? `https://image.tmdb.org/t/p/w200${movie.poster_path}` : 'https://via.placeholder.com/100x150.png?text=No+Image',
      overview: movie.overview
    }));
  } catch (error: any) {
    Logger.log("Error in searchTmdb: " + error);
    throw new Error("Erreur lors de la recherche TMDB: " + error.message);
  }
}

/**
 * Fetches detailed movie information from TMDB by ID.
 * @param {number} tmdbId The TMDB movie ID.
 * @return {Object} Detailed movie information.
 */
/**
 * Fetches detailed movie information from TMDB by ID AND attempts to fetch ratings from OMDb.
 * @param {number} tmdbId The TMDB movie ID.
 * @return {Object} Detailed movie information including ratings if found.
 */
function getTmdbDetails(tmdbId: number): any {
  let tmdbData: any = {}; // To store TMDB results
  let omdbData: any = {}; // To store OMDb results

  // --- Step 1: Fetch from TMDB (Now in English) ---
  try {
    const apiKey = getTmdbApiKey();
    const url = `https://api.themoviedb.org/3/movie/${tmdbId}?api_key=${apiKey}&language=en-US&append_to_response=credits,videos`; // <-- Language changed to en-US
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const json = JSON.parse(response.getContentText());

    if (response.getResponseCode() !== 200) {
      Logger.log("TMDB Details Error: " + response.getContentText());
      throw new Error("TMDB API error fetching details.");
    }
    tmdbData = json; // Store the raw TMDB response

  } catch (error: any) {
    Logger.log("Error fetching TMDB details: " + error);
    // Don't necessarily stop if TMDB fails, maybe OMDb can still work if we have an ID somehow?
    // Or rethrow if TMDB is essential:
    throw new Error("Error fetching TMDB details: " + error.message);
  }

  // --- Extract essential data from TMDB ---
  const title = tmdbData.title || 'Unknown Title';
  const plot = tmdbData.overview || '';
  const durationMinutes = tmdbData.runtime || 0;
  const duration = durationMinutes > 0 ? `${Math.floor(durationMinutes / 60)}h ${durationMinutes % 60}min` : '';
  const genres = tmdbData.genres ? tmdbData.genres.map((g: any) => g.name).join(', ') : '';
  const year = tmdbData.release_date ? tmdbData.release_date.substring(0, 4) : '';
  const posterPath = tmdbData.poster_path ? `https://image.tmdb.org/t/p/w500${tmdbData.poster_path}` : null;
  const imdbId = tmdbData.imdb_id || null; // Get IMDb ID from TMDB

  let director = '';
  if (tmdbData.credits && tmdbData.credits.crew) {
    const directorObj = tmdbData.credits.crew.find((person: any) => person.job === 'Director');
    if (directorObj) director = directorObj.name;
  }

  let actors = '';
  if (tmdbData.credits && tmdbData.credits.cast) {
    actors = tmdbData.credits.cast.slice(0, 3).map((actor: any) => actor.name).join(', ');
  }

  // Find YouTube Trailer Link from TMDB videos
  let trailerLink = null;
  if (tmdbData.videos && tmdbData.videos.results && tmdbData.videos.results.length > 0) {
    const youtubeTrailer = tmdbData.videos.results.find((v: any) => v.site === 'YouTube' && v.type === 'Trailer' && v.iso_639_1 === 'en'); // Prefer English trailer
     if (!youtubeTrailer) { // Fallback to any YouTube trailer if no English one
         youtubeTrailer = tmdbData.videos.results.find((v: any) => v.site === 'YouTube' && v.type === 'Trailer');
     }
    if (youtubeTrailer) {
      trailerLink = `https://www.youtube.com/watch?v=${youtubeTrailer.key}`;
    }
  }

  // --- Step 2: Fetch Ratings from OMDb using IMDb ID ---
  let omdbImdbScore = '';
  let omdbRtScore = '';
  const omdbApiKey = getOmdbApiKey();

  if (imdbId && omdbApiKey) { // Only proceed if we have IMDb ID and OMDb key
    try {
      const omdbUrl = `http://www.omdbapi.com/?apikey=${omdbApiKey}&i=${imdbId}`;
      const omdbResponse = UrlFetchApp.fetch(omdbUrl, { muteHttpExceptions: true });
      const omdbJson = JSON.parse(omdbResponse.getContentText());

      if (omdbResponse.getResponseCode() === 200 && omdbJson.Response === "True") {
        omdbData = omdbJson; // Store OMDb response
        omdbImdbScore = omdbData.imdbRating && omdbData.imdbRating !== "N/A" ? omdbData.imdbRating : '';

        // Find Rotten Tomatoes score
        if (omdbData.Ratings && Array.isArray(omdbData.Ratings)) {
          const rtRating = omdbData.Ratings.find((r: any) => r.Source === "Rotten Tomatoes");
          if (rtRating && rtRating.Value && rtRating.Value !== "N/A") {
            omdbRtScore = rtRating.Value.replace('%', ''); // Store only the number
          }
        }
        Logger.log(`OMDb Ratings Found: IMDb=${omdbImdbScore}, RT=${omdbRtScore}`);
      } else {
         Logger.log(`OMDb API Response Error for ${imdbId}: ${omdbResponse.getContentText()}`);
      }
    } catch (error) {
      Logger.log(`Error fetching OMDb data for ${imdbId}: ${error}`);
    }
  } else {
     Logger.log(`Skipping OMDb fetch: imdbId=${imdbId}, omdbApiKeyExists=${!!omdbApiKey}`);
  }


  // --- Consolidate and Return ---
  return {
    title: title,
    plot: plot,
    duration: duration,
    genres: genres,
    director: director,
    actors: actors,
    year: year,
    posterUrl: posterPath,
    imdbLink: imdbId ? `https://www.imdb.com/title/${imdbId}/` : null, // Link to IMDb page
    trailerLink: trailerLink, // Link to YouTube trailer IF found
    imdbScore: omdbImdbScore, // From OMDb
    rtScore: omdbRtScore,     // From OMDb
    // Default values for modal
    dateAdded: new Date().toLocaleDateString('en-US'),
    status: 'Vu', // Default 'Watched'
    suite: 'FALSE',
    remarques: '',
    note: ''
  };
}

/**
 * Adds a new movie row to the Google Sheet based on TMDB details.
 * @param {Object} movieData The detailed movie data object gathered FROM THE MODAL.
 * @return {string} Success message.
 */
function addMovie(movieData: any): string {
  // --- Start Logging ---

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // Determine target sheet based on status: put "À voir"/"A voir" films in sheet named "A voir"
    let targetSheetName = 'Reading Log';
    try {
      let statusRaw = movieData && movieData.status ? String(movieData.status).trim().toLowerCase() : '';
      // Remove diacritics to match variants like 'à voir' / 'A voir' / 'A-voir'
      try {
        statusRaw = statusRaw.normalize('NFD').replace(/\p{Diacritic}/gu, '');
      } catch (e) {
        // Fallback for environments where Unicode property escapes may not be supported
        statusRaw = statusRaw.replace(/[\u0300-\u036f]/g, '');
      }
      const toWatchVariants = ['a voir', 'a-voir', 'avoir', 'a voir', 'a-voir'];
      if (toWatchVariants.indexOf(statusRaw) !== -1) {
        targetSheetName = 'A voir';
      }
    } catch (e) {
      // Fallback to default sheet name
      targetSheetName = 'Reading Log';
    }

    // Ensure the target sheet exists. If not, try to copy headers from Reading Log or create defaults.
    let sheet = ss.getSheetByName(targetSheetName);
    if (!sheet) {
      const sourceSheet = ss.getSheetByName('Reading Log');
      if (sourceSheet) {
        const headersFromSource = sourceSheet.getRange(1, 1, 1, sourceSheet.getLastColumn()).getValues()[0];
        sheet = ss.insertSheet(targetSheetName);
        sheet.getRange(1, 1, 1, headersFromSource.length).setValues([headersFromSource]);
      } else {
        // Create sheet with reasonable default headers if Reading Log doesn't exist
        sheet = ss.insertSheet(targetSheetName);
        const defaultHeaders = ['DATE','I','T','TITRE FILM','PLOT','DUREE','GENRES','REALISATEUR','ACTEURS','YEAR','REMARQUES','STATUS','SUITE A VOIR (OU PREVUE)','RT','IMDB','NOTE'];
        sheet.getRange(1, 1, 1, defaultHeaders.length).setValues([defaultHeaders]);
      }
    }

    if (!sheet) {
       const message = `La feuille '${targetSheetName}' est introuvable ! Impossible d'ajouter le film.`;
       Logger.log(message); // Log the specific error
       throw new Error(message);
     }

    // Get headers FROM THE CORRECT SHEET
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

    // --- Construct the row array based on header order ---
    const newRow = headers.map(header => {
       const headerUpper = String(header).toUpperCase().trim();
       let value: any = '';

       switch (headerUpper) {
          // ... (keep your existing switch cases here) ...
           case 'DATE':
               value = movieData.dateAdded || new Date().toLocaleDateString('en-US');
               // Basic validation/reformatting if needed
               try {
                   const parts = value.split('/');
                   if (parts.length === 3) value = `${parts[0]}/${parts[1]}/${parts[2]}`;
                   else value = new Date().toLocaleDateString('en-US');
               } catch (e) { value = new Date().toLocaleDateString('en-US'); }
               break;
           case 'I':
               value = movieData.posterUrl ? `=HYPERLINK("${movieData.posterUrl}","I")` : 'I';
               break;
           case 'T':
               const primaryLink = movieData.trailerLink || movieData.imdbLink;
               value = primaryLink ? `=HYPERLINK("${primaryLink}","T")` : 'T'; // Use T if neither link exists
               break;
           case 'TITRE FILM':
               value = movieData.title || '';
               break;
           case 'PLOT':
               value = movieData.plot || '';
               break;
           case 'DUREE':
               value = movieData.duration || '';
               break;
           case 'GENRES':
               value = movieData.genres || '';
               break;
           case 'REALISATEUR':
               value = movieData.director || '';
               break;
           case 'ACTEURS':
               value = movieData.actors || '';
               break;
           case 'YEAR':
               value = movieData.year || '';
               break;
           case 'REMARQUES':
               value = movieData.remarques || '';
               break;
           case 'STATUS':
               value = movieData.status || 'Vu';
               break;
           case 'SUITE A VOIR (OU PREVUE)':
               value = movieData.suite ? String(movieData.suite).toUpperCase() : 'FALSE';
               break;
           case 'RT':
               value = movieData.rtScore || '';
               break;
           case 'IMDB':
               value = movieData.imdbScore || '';
               break;
           case 'NOTE':
               const noteVal = parseFloat(movieData.note);
               value = !isNaN(noteVal) ? noteVal : '';
               break;
           default:
               value = '';
               break;
       }
       // Logger.log(`Header: ${header}, Value Mapped: ${value}`); // Optional: Uncomment for very detailed per-column debugging
       return value;
    });

    if (headers.length !== newRow.length) {
        const errorMsg = `Mismatch between header count (${headers.length}) and generated row count (${newRow.length}). Cannot append. Row data: ${JSON.stringify(newRow)}`;
        throw new Error(errorMsg);
    }

    // --- Append the Row ---
    sheet.appendRow(newRow);
    SpreadsheetApp.flush(); // Ensure changes are saved immediately

    return `"${movieData.title}" ajouté avec succès à '${sheet.getName()}' !`;

  } catch (error: any) {
     throw new Error("Impossible d'ajouter le film à la feuille: " + error.message); // Rethrow for client-side
  }
}